# 项目：DDL 任务提醒器 (Task Manager) - 开发日志

## 阶段一：需求与规划 (The "Thinking")

*日期：2025年10月27日*

### 1.1 项目愿景 (Why)

启动这个项目的核心目标是：
1.  **学习与实践：** 亲手走完一个 Python Web 项目的完整开发流程（从 0 到 1），掌握 Flask、SQLAlchemy、自动化脚本等技能。
2.  **解决痛点：** 创建一个自用的、极简的待办事项工具，解决个人忘记 DDL 的问题。

### 1.2 核心功能清单 (What)
本项目将实现以下**最小可行产品 (MVP)** 功能：

#### A. 任务管理 (Web 界面)
* **[F-01] 创建任务：** 用户可以添加新任务（包含标题和 DDL）。
* **[F-02] 查看任务：** 用户可以查看所有的、未完成的任务列表。
* **[F-03] 完成任务：** 用户可以标记一个任务为“已完成”。
* **[F-04] 删除任务：** 用户可以删除一个任务。


#### B. 自动化 (后台脚本)
* **[F-05] 检查 DDL：** 系统能自动地（每天一次）检查所有任务。
* **[F-06] 发送提醒：** 系统对 7 天或3天内到期、未完成、且未提醒过的任务，发送邮件提醒。
* **[F-07] 防止重复：** 系统必须确保同一个任务只被提醒一次。

## 阶段二：设计与蓝图 (The "How")
*日期：2025年10月27日*


### 2.1 技术选型 (Tech Stack)
为了实现上述功能，我们选择以下技术栈：
* **后端框架：** `Python` + `Flask` (用于处理网页请求)。
* **数据存储：** `SQLite` (一个简单的 .db 文件，非常适合入门)。
* **数据库 ORM：** `Flask-SQLAlchemy` (让我们能用 Python 类来操作数据库)。
* **页面模板：** `Jinja2` (Flask 自带，用来写 HTML 页面)。
* **后台任务：** 独立的 `Python` 脚本 (用于发邮件)。
* **定时调度：** `Cron` (Linux 内置的定时器) 或 `Windows 任务计划程序`。

## 2.2 数据建模 (Data Modeling)
这是项目的“地基”。根据 [阶段一] 的功能需求，我们推导出我们只需要一个核心模型（一张表）：**`Task`** (任务)。

| 字段名 (Column) | 数据类型 (Type) | 规则 (Rules) | 备注 (Why we need this?) |
| :--- | :--- | :--- | :--- |
| `id` | Integer | Primary Key (主键) | 数据库的唯一“身份证号”，用于 [F-03], [F-04] |
| `title` | String(200) | Not Null (不能为空) | **[F-01]** 任务的标题 |
| `due_date` | Date | Nullable (可为空) | **[F-01]** 任务的 DDL，用于 [F-05] |
| `is_completed` | Boolean | Default: `False` | **[F-03]** 标记任务是否完成，用于 [F-02], [F-06] |

### 2.3 架构设计 (Architecture)
本项目采用“**Web 服务 + 后台任务**”分离的架构。
1.  **Web 服务 (`app.py`)：**
    * 角色：餐厅的“**服务员**”。
    * 职责：7x24 小时运行，被动地**响应**用户的网页访问（增、删、改、查任务）。
2.  **后台任务 (`check_ddl.py`)：**
    * 角色：餐厅的“**后勤**”。
    * 职责：**不**对外服务。每天凌晨 1 点被 `Cron` **主动**唤醒一次，去**检查**数据库，完成“发邮件”和“更新 `is_notified` 状态”的工作，然后退出。
3.  **沟通方式：**
    * 这两个独立的部分，通过**共享**同一个 `todo.db` 数据库文件来进行“沟通”。

#### 流程 B: 系统自动发送提醒 (后台流程) - V3.0 (每日简报版)

1.  **[Cron]** (定时器) 在每天凌晨 1 点，自动执行 `python3 check_ddl.py` 脚本。
2.  **[Python 脚本]** **连接**到 `todo.db` 数据库。
3.  **[Python 脚本]** 定义一个“提醒窗口”，比如 `REMINDER_WINDOW = 7` (天)。
4.  **[Python 脚本]** 创建一个**空的列表**，比如 `tasks_to_notify = []`。
5.  **[Python 脚本]** **查询 (Query)** 数据库，找出**所有**满足以下**全部**条件的任务：
    * `is_completed` == `False` (未完成)
    * `due_date` <= (今天 + `REMINDER_WINDOW` 天) (在提醒窗口内)
    * `due_date` >= (今天) (防止提醒已过期的)
6.  **[Python 脚本]** **遍历 (Loop)** 查到的所有任务，把它们**添加**到 `tasks_to_notify` 列表中。
7.  **[Python 脚本]** **检查列表：**
    * **IF** `tasks_to_notify` 列表**不为空**：
        a.  (新逻辑) **构建一封**邮件正文，包含**所有**在列表中的任务（比如一个 HTML 列表）。
        b.  (核心-网络) 使用 `smtplib` **只发送一封**“今日 DDL 提醒简报”邮件。
    * **ELSE** (列表为空)：
        a.  (新逻辑) 脚本**什么也不做**，安静退出。
8.  **[Python 脚本]** 结束。（**注意：** 我们不再需要更新数据库了！）